
package com.quickblox.reactnative.auth;

import android.os.Bundle;
import android.text.TextUtils;

import com.facebook.react.bridge.Promise;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;
import com.facebook.react.bridge.ReadableMap;
import com.facebook.react.bridge.WritableMap;
import com.facebook.react.bridge.WritableNativeMap;
import com.quickblox.auth.session.QBSession;
import com.quickblox.auth.session.QBSessionManager;
import com.quickblox.core.QBEntityCallback;
import com.quickblox.core.exception.QBResponseException;
import com.quickblox.reactnative.helpers.DateHelper;
import com.quickblox.users.QBUsers;
import com.quickblox.users.model.QBUser;

import java.util.Date;

public class AuthModule extends ReactContextBaseJavaModule {
    private static final String MODULE_NAME = "RNQBAuthModule";

    public AuthModule(ReactApplicationContext reactContext) {
        super(reactContext);
    }

    @Override
    public String getName() {
        return MODULE_NAME;
    }

    @ReactMethod
    public void login(ReadableMap data, final Promise promise) {
        String login = data != null && data.hasKey("login") ? data.getString("login") : null;
        String password = data != null && data.hasKey("password") ? data.getString("password") : null;

        QBUsers.signIn(login, password).performAsync(new QBEntityCallback<QBUser>() {
            @Override
            public void onSuccess(QBUser qbUser, Bundle bundle) {
                WritableMap map = new WritableNativeMap();

                WritableMap user = AuthMapper.qbUserToMap(qbUser);
                map.putMap("user", user);

                QBSessionManager.getInstance().getActiveSession().setUserId(qbUser.getId());
                QBSession qbSession = QBSessionManager.getInstance().getActiveSession();
                WritableMap session = AuthMapper.qbSessionToMap(qbSession);
                map.putMap("session", session);

                promise.resolve(map);
            }

            @Override
            public void onError(QBResponseException e) {
                promise.reject(e);
            }
        });
    }

    @ReactMethod
    public void logout(final Promise promise) {
        QBUsers.signOut().performAsync(new QBEntityCallback<Void>() {
            @Override
            public void onSuccess(Void aVoid, Bundle bundle) {
                promise.resolve(aVoid);
            }

            @Override
            public void onError(QBResponseException e) {
                promise.reject(e);
            }
        });
    }

    @ReactMethod
    public void setSession(ReadableMap data, final Promise promise) {
        String token = data != null && data.hasKey("token") ? data.getString("token") : null;
        String tokenExpirationDate = data != null && data.hasKey("expirationDate") ? data.getString("expirationDate") : null;
        Integer userId = data != null && data.hasKey("userId") ? data.getInt("userId") : null;
        Integer applicationId = data != null && data.hasKey("applicationId") ? data.getInt("applicationId") : null;

        if (TextUtils.isEmpty(token)) {
            promise.reject(new Exception("token is required"));
            return;
        }
        if (TextUtils.isEmpty(tokenExpirationDate)) {
            promise.reject(new Exception("expirationDate is required"));
            return;
        }
        if (userId == null || userId <= 0) {
            promise.reject(new Exception("userId is required"));
            return;
        }
        if (applicationId == null || applicationId <= 0) {
            promise.reject(new Exception("applicationId is required"));
            return;
        }

        Date parsedExpirationDate = DateHelper.convertRawToDateISO(tokenExpirationDate);
        if (parsedExpirationDate == null) {
            promise.reject(new Exception("expirationDate has a wrong format"));
            return;
        }

        QBSessionManager.getInstance().createActiveSession(token, parsedExpirationDate);
        QBSession qbSession = QBSessionManager.getInstance().getActiveSession();

        qbSession.setUserId(userId);
        qbSession.setAppId(applicationId);

        WritableMap session = AuthMapper.qbSessionToMap(qbSession);
        promise.resolve(session);
    }

    @ReactMethod
    public void getSession(final Promise promise) {
        QBSession qbSession = QBSessionManager.getInstance().getActiveSession();

        if (qbSession != null) {
            WritableMap session = AuthMapper.qbSessionToMap(qbSession);
            promise.resolve(session);
        } else {
            promise.resolve(null);
        }
    }
}