//
//  QBAuthModule.m
//  quickblox_sdk
//
//  Created by Injoit on 23.12.2019.
//  Copyright Â© 2019 Injoit LTD. All rights reserved.
//

#import "QBAuthModule.h"
#import "QBAuthConstants.h"
#import "QBSession+QBSerializer.h"
#import "QBUUser+QBSerializer.h"
#import "NSDate+Helper.h"

@implementation QBAuthModule

- (void)login:(NSDictionary *)info
     resolver:(QBResolveBlock)resolve
     rejecter:(QBRejectBlock)reject {
  
  NSObject *loginObject = info[AuthKey.login];
  if ([NSError reject:reject
         checkerClass:NSString.class
               object:loginObject
            objectKey:AuthKey.login]) {
    return;
  }
  NSString *login = (NSString *)loginObject;
  
  NSObject *passwordObject = info[AuthKey.password];
  if ([NSError reject:reject
         checkerClass:NSString.class
               object:passwordObject
            objectKey:AuthKey.password]) {
    return;
  }
  NSString *password = (NSString *)passwordObject;
  [QBRequest logInWithUserLogin:login
                       password:password
                   successBlock:^(QBResponse *response,
                                  QBUUser *user) {
    NSError *error = nil;
    NSDictionary *sessionData = [[QBSession currentSession] toQBResultData:&error];
    NSDictionary *userData = [user toQBResultData:&error];
    if ([error reject:reject]) {
      return;
    }
    if (resolve) {
      resolve(@{ AuthKey.user: userData,
                 AuthKey.session: sessionData });
    }
  } errorBlock:^(QBResponse *response) {
    [response reject:reject];
  }];
}

- (void)logout:(QBResolveBlock)resolve
      rejecter:(QBRejectBlock)reject {
  [QBRequest logOutWithSuccessBlock:^(QBResponse *response) {
    if (resolve) {
      resolve(nil);
    }
  } errorBlock:^(QBResponse *response) {
    [response reject:reject];
  }];
}

- (void)setSession:(NSDictionary *)info
          resolver:(QBResolveBlock)resolve
          rejecter:(QBRejectBlock)reject {
  if ([NSError reject:reject
                 info:info
         requirements:@[ [Requirement class:NSString.class
                                        key:QBSessionKey.token],
                         [Requirement class:NSString.class
                                        key:QBSessionKey.expirationDate],
                         [Requirement class:NSNumber.class
                                        key:QBSessionKey.userId],
                         [Requirement class:NSNumber.class
                                        key:QBSessionKey.applicationId] ]
       ]) { return; }
  
  NSString *expirationDate = info[QBSessionKey.expirationDate];
  NSDate *date = [NSDate dateFromQBTokenHeader:expirationDate];
  if (!date) {
    NSString *message = [NSString stringWithFormat:@"%@ has a wrong format",
                         QBSessionKey.expirationDate];
    [NSError reject:reject
            message:message];
    return;
  }
  
  QBASession *session = [[QBASession alloc] init];
  session.token = info[QBSessionKey.token];
  NSNumber *userId = info[QBSessionKey.userId];
  session.userID = userId.unsignedIntValue;
  NSNumber *applicationId = info[QBSessionKey.applicationId];
  session.applicationID = applicationId.unsignedIntValue;
  
  QBSession *currentSession = [QBSession currentSession];
  [currentSession startSessionWithDetails:session
                           expirationDate:date];
  [currentSession toQBResultDataWithResolver:resolve rejecter:reject];
}

- (void)getSession:(QBResolveBlock)resolve
          rejecter:(QBRejectBlock)reject {
  if (!resolve) { return; }
  
  NSError *error = nil;
  NSDictionary *data = [[QBSession currentSession] toQBResultData:&error];
  NSString *token = data[QBSessionKey.token];
  if (token.length) {
    resolve(data);
    return;
  }
  
  resolve(nil);
}

@end
